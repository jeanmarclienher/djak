class linked {
field linked parent;
field linked left;
field linked right;
field linked child;
field array data1;
field array data2;
field int flags;

constructor linked new(in linked parent_, in linked left_, in linked right_)
{
	parent := parent_;
	left := left_;
	right := right_;
	child := null;
	data1 := null;
	data2 := null;
	flags := 0;
	return this;
}

method void dispose()
{
	// FIXME free children and data
	std.free(this);
	return;
}

method void set_flags(in int f)
{
	flags := f;
	return;
}

method int get_flags()
{
	return flags;
}

method void set_data1(in array d)
{	
	data1 := d;
	return;
}
method void set_data2(in array d)
{	
	data2 := d;
	return;
}
method array get_data1()
{
	return data1;
}

method array get_data2()
{
	return data2;
}

method void set_parent(in linked p)
{	
	parent := p;
	return;
}

method linked get_parent()
{
	return parent;
}

method void set_right(in linked p)
{	
	right := p;
	return;
}

method linked get_right()
{
	return right;
}

method void set_left(in linked p)
{	
	left := p;
	return;
}

method linked get_left()
{
	return left;
}

method void set_child(in linked p)
{	
	child := p;
	return;
}

method linked get_child()
{
	return child;
}

method int replace_to_left(in linked cur, in linked by)
{
	if (right == cur) {
		right := by;
	} else if (left == cur) {
		left := by;
	} else if (child == cur) {
		child := by;
	} else {
		return 0;
	}
	by.set_parent(this);
	cur.set_parent(by);
	by.set_left(cur);
	return 1;
}

method void pad(in int depth) 
{
	var int i;
	i := depth;
	while (i > 0) {
		i := i - 1;
		console.log_str("  ");
	}
	return;
}

method void dump(in int depth)
{
	var string s;
	var Atoken to;
	if (this == null) {
		return;
	}
	if (data1 != null) {
		to := data1;
		s := to.get_data();
	} else {
		s := "";
	}
	pad(depth);
	console.log_int(this);
	console.log_str(" ");
	console.log(s);
	pad(depth);
	console.log("L");
	left.dump(depth + 1);
	pad(depth);
	console.log("R");
	right.dump(depth + 1);
	return;
}

} // class
